# llvm-jit-ptx

This demonstrates run-time fusion of a kernel that calles a device function. The device functions go in the [dfunc](dfunc/) crate, which is `no_std` and included both as a regular crate on the host (where it's easily tested) and compiled to LLVM-IR.

In one mode, `build.rs` compiles to PTX. In the second, the linking and compilation to PTX is done at run-time. Either way, the PTX is loaded and run using the CUDA device API.

## Installation

This is needed to build device functions.

```console
$ rustup target add --toolchain nightly nvptx64-nvidia-cuda
```

## Notes

* [nvJitLink](https://developer.nvidia.com/blog/cuda-12-0-compiler-support-for-runtime-lto-using-nvjitlink-library/) provides a way to link together artifacts from different sources into a fused kernel. It works with LTO-IR, which must match the major version of libnvJitLink. LTO-IR can be generated by NVCC and NVRTC, but not to my knowledge by upstream LLVM.
* We could avoid needing to pre-install the `nvptx64-nvidia-cuda` toolchain by using the nightly-only flag [`-Z build-std`](https://doc.rust-lang.org/cargo/reference/unstable.html#build-std).
